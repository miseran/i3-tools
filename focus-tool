#!/usr/bin/env python3
# vim: noet ts=2 sw=2

import i3ipc
import sys

conn = i3ipc.Connection()

tree = conn.get_tree()


def focused_order(node):
	"""Iterate through the children of "node" in most recently focused order."""
	for focus_id in node.focus:
		yield next(n for n in node.nodes if n.id == focus_id)


def focused_child(node):
	"""Return the most recently focused child of "node"."""
	return next(focused_order(node))


def is_in_line(old, new, direction):
	"""
	Return true if container "new" can reasonably be considered to be in
	direction "direction" of container "old".
	"""
	if direction in ["up", "down"]:
		return new.rect.x <= old.rect.x + old.rect.width*0.9 \
				and new.rect.x + new.rect.width >= old.rect.x + old.rect.width*0.1
	elif direction in ["left", "right"]:
		return new.rect.y <= old.rect.y + old.rect.height*0.9 \
				and new.rect.y + new.rect.height >= old.rect.y + old.rect.height*0.1


def output_in_direction(output, window, direction):
	"""
	Return the output in direction "direction" of window "window" on output
	"output".
	"""
	for new in focused_order(tree):
		if new.name == "__i3":
			continue
		if not is_in_line(window, new, direction):
			continue
		orct = output.rect
		nrct = new.rect
		if (direction == "left" and nrct.x + nrct.width == orct.x) \
				or (direction == "right" and nrct.x == orct.x + orct.width) \
				or (direction == "up" and nrct.y + nrct.height == orct.y) \
				or (direction == "down" and nrct.y == orct.y + orct.height):
			return new

	return None


def focus_direction(direction):
	"""
	Focus the container that is *visually* in direction "direction". If there are
	multiple candidates, (usually) pick the most recently focused one.
	"""
	if direction in ["left", "right"]:
		splitx = "splith"
	elif direction in ["up", "down"]:
		splitx = "splitv"
	if direction in ["down", "right"]:
		last = -1
		first = 0
		delta = 1
	elif direction in ["up", "left"]:
		last = 0
		first = -1
		delta = -1

	node = start = tree.find_focused()

	# Find innermost parent in which we can move in the desired direction,
	# then move.
	while True:
		parent = node.parent
		if node.type == "workspace":
			node = output_in_direction(node.parent.parent, start, direction)
			if not node:
				return
			node = next(n for n in node.nodes if n.type != "dockarea")
			node = focused_child(node)
			break
		if not parent or node.type != "con":
			return
		if parent.layout == splitx and parent.nodes[last] != node:
			index = parent.nodes.index(node)
			node = parent.nodes[index + delta]
			break
		node = parent

	# Find an appropriate leaf to focus.
	while node.nodes:
		if node.layout in ["tabbed", "stacked"]:
			# Choose most recently focused tab.
			node = focused_child(node)
		elif node.layout == splitx:
			# Choose nearest child to original container.
			node = node.nodes[first]
		else:
			# Choose the most recently focused child that can reasonably be
			# considered adjacent to the original container.
			for new in focused_order(node):
				if is_in_line(start, new, direction):
					node = new
					break
			else:
				# No appropriate child found, just focus any one.
				node = node.nodes[0]

	conn.command('[con_id="{id}"] focus'.format(id=node.id))


def focus_tab(direction):
	"""
	Cycle through the innermost stacked or tabbed ancestor container, or through
	floating containers.
	"""
	if direction == "tab-next":
		delta = 1
	elif direction == "tab-prev":
		delta = -1

	node = tree.find_focused()

	# Find innermost tabbed or stacked container, or detect floating.
	while True:
		parent = node.parent
		if not parent or node.type != "con":
			return
		if parent.layout in ["tabbed", "stacked"] or parent.type == "floating_con":
			break
		node = parent

	if parent.type == "floating_con":
		node = parent
		parent = node.parent
		# The order of floating_nodes is not useful, sort it somehow.
		parent_nodes = sorted(parent.floating_nodes, key=lambda n: n.id)
	else:
		parent_nodes = parent.nodes

	index = parent_nodes.index(node)
	node = parent_nodes[(index + delta) % len(parent_nodes)]

	# Find most recently focused leaf in new tab.
	while node.nodes:
		node = focused_child(node)

	conn.command('[con_id="{id}"] focus'.format(id=node.id))


def main(direction):
	if direction in ["left", "right", "up", "down"]:
		focus_direction(direction)
	elif direction in ["tab-next", "tab-prev"]:
		focus_tab(direction)
	else:
		print("Usage: focus_tool [left|right|up|down|tab-next|tab-prev]")
		exit(1)


if __name__ == "__main__":
	if len(sys.argv) != 2:
		print("Usage: focus_tool [left|right|up|down|tab-next|tab-prev]")
		exit(1)
	main(sys.argv[1])
